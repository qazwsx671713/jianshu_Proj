1. 路由的安装与使用
    安装：
        npm i react-router-dom
    使用：
        -1. 在index.js中：
            import {BrowserRouter} from 'react-router-dom'
            # 使用BrowserRouter标签包裹住app，在app中使用路由
                <BrowserRouter>
                    <App />
                </BrowserRouter>
        -2. 在需要展示路由的组件中：
            import {Link,Router}
            # 使用link指定history操作链接变化
            <Link to='/Home'>首页</Link>
            # 使用Route标签，检测链接变化时，展示对应网页
            # 需要用Routes标签包裹Route，这是新版本的写法
            <Routes>
                <Route path='/Home' element={<Home/>}></Route>
            </Routes>

2. 引用public目录下的文件
    如果在index.html中，你可以像这样去使用它：
        <img src="%PUBLIC_URL%/image/poster.jpeg" alt="">
    在JavaScript代码中，可以process.env.PUBLIC_URL出于类似目的使用：
        render() {
            return <img src={process.env.PUBLIC_URL + '/img/logo.png'} />;
        }

3. 使用iconfont库
    https://blog.csdn.net/qq_52077949/article/details/119880227

4. 函数式组件props的使用：
    定义时就声明形参中的props，然后解构赋值，然后使用
        export default function TopicItem(props) {
            const {title} = props
            return (
                <div class='topicItem-container clearfix'>
                    <a href="#" className='iconfont icon-bingqilin TopicItem-icon'></a>
                    <p className='TopicItem-content'> {title}</p>
                </div>
            )
        }

    传入参数方法：
        # 给props传入title参数
        也有这样用的{...p,title={value}}
        <TopicItem title={value}/>

5. 单行和多行文本溢出显示省略号
    单行文本溢出
    如果解决文本溢出显示省略号，需要满足的三个条件：

    先强制一行内显示文本
    white-space:nowrap;/*默认normal 自动换行*/

    超出的文本隐藏起来。
    overflow:hidden;

    文本省略部分替代超出的部分
    text-overflow:ellipsis; /*默认是clip 超出部分直接切除*/

    ***********************************************************

    多行文本溢出
    多行文本溢出显示省略号，有较大的兼容性问题，适合于webkit’浏览器火移动端（移动端大部分是webkit内核。）
    上面的原因也是为什么不建议在前端通过CSS进行设置，而是要求后台返回的数据就是带有省略号的规定内容。

    隐藏超出部分
    overflow:hidden;

    弹性伸缩盒子模型显示：
    display：-webkit-box;

    限制一个块元素显示的文本行数
    -webkit-line-clamp:2;

    设置或检索伸缩盒对象的子元素的排列方式
    -webkit-box-orient:vertical;

6. 自适应窗口大小


7. 异步数据获取，但是组件提前更新
    组件需要从xxx数据中，读取数据并显示，但是再进入网页时，再数据还没返回时，就已经显示组件，报错。
    解决：
        整个流程为：
            App初始render->ajax请求数据->组件展示数据
            但ajax收到数据组件就展示数据了，因此整个流程其实为：
            App初始render->ajax请求数据->组件展示空数据->ajax收到数据->重新render->组件展示数据

        报错语句其实是：data.map() 报错undefined没有map，其实就是组件再展示数据的时候出错了。
        修改空数据时，data不为undefined，而是[]即可。
            let usr_list = []
            if (artist_data_list!==undefined){
                usr_list = artist_data_list.users
            }

    也就是说，我们的组件一定是：
        1.还没数据前展示空数据，或是如果是判断如果是空数据，那先不展示。
        2.接收到数据后，dispatch再展示。
        因此，我们一定要做到空数据、无数据时的处理。



8. 旋转动画
    # 首先要旋转的元素要设置为inline-block，不然动画会无效
    display：inline-block
    # 设置transition监控rotate
    transition:transform 1s linear;

    # 注意，用什么改变属性就要监控什么
    # 同样是旋转，监控的东西不一样

        # 例如用rotate改变属性
        *************************************
        *   transition:rotate 1s linear;
        *   rotate:360deg
        *************************************

        # 例如用transform改变属性
        *************************************
        *   transition:transform 1s linear;
        *   transform:360deg
        *************************************
    
9. 如何用函数式组件获取dom元素以及其style？

    const FComponent = () => {
    const refDiv = useRef();

    ** console.log(refDiv.current);
    ** console.log(refDiv.current.style);

    return <div>
        <div className="demo" ref={refDiv}>test</div>
    </div>

10. 函数式组件修改dom元素style
    const refresh_on = ()=>{
        rotate_item.current.style.rotate = "360deg"
    }
    style改变，会直接引起css变化，然后对应元素发生变化
    transition监控到css变化，产生动画效果

11. 完整的动画效果实现
    css：
        .writer-rotate{
            rotate: 0deg;
            transition:rotate 1s linear;
        }
    函数式组件中：
            const refresh_on = ()=>{
                console.log(rotate_item.current.style)
                const now_rotate = rotate_item.current.style.rotate
                if(now_rotate===''){
                    // console.log('111')
                    rotate_item.current.style.rotate = "360deg"
                }
                else{
                    console.log(now_rotate.slice(0,-3))
                    const new_rotate =parseInt(now_rotate.slice(0,-3))
                    const str_rotate = (new_rotate+360)+'deg'
                    console.log(str_rotate)
                    rotate_item.current.style.rotate = str_rotate

                }
            }
    css中监控了rotate属性
    函数式组件中设置了点击事件，当点击时，改变css中的rotate
    然后css中的transition感受到rotate的变化，产生动画效果。

12. 制作回到顶部功能
    该按钮在可视窗口中的位置是固定的
    使用以下语句实现：
        position:fixed
    
    当页面不再顶部的时候，该按钮才出现，在顶部时，该按钮消失

    1.绑定窗口滑动事件
    window.addEventListener('scroll',changeScreenProps)
    2.获取当前滚动值
    document.documentElement.scrollTop
    3.判断滚动值，当大于某个阈值时显示按钮。

13. Link包裹的区域不能再有a标签
    因为点击该位置时，系统就不知道该按a标签跳转还是按Link跳转
    因此，将Link包裹住的a标签全部换成link标签。